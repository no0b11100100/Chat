// Code generated by goqface. DO NOT EDIT.
package api

import (
    "encoding/json"
    "net"
    "net/textproto"
    "bufio"
    "fmt"
)

//enums
type ResponseStatus int

const (
OK = 0
Error = 1
)

//structs
type Response struct {
    UserID string `json:"UserID"`
    Name string `json:"Name"`
    NickName string `json:"NickName"`
    Photo string `json:"Photo"`
    Status ResponseStatus `json:"Status"`
    StatusMessage string `json:"StatusMessage"`
}
type SignIn struct {
    Email string `json:"Email"`
    Password string `json:"Password"`
}
type SignUp struct {
    Name string `json:"Name"`
    NickName string `json:"NickName"`
    Email string `json:"Email"`
    Password string `json:"Password"`
    ConfirmedPassword string `json:"ConfirmedPassword"`
    Photo string `json:"Photo"`
}

//server
type UserServiceConnectionCallback = func(string, UserServiceNotifier)

type UserServiceServerImpl interface {
    SignIn(ServerContext,SignIn,) Response
    SignUp(ServerContext,SignUp,) Response
}

type UserServiceNotifier interface {
}

type UserServiceNotificator struct {
	conn net.Conn
}




type UserServiceServer struct {
	listener              net.Listener
	impl                  UserServiceServerImpl
	notifierObservers     []UserServiceConnectionCallback
	disconectionObservers []disconnectionCallback
}

func NewUserServiceServer(addr string) *UserServiceServer {
	ln, _ := net.Listen("tcp", addr)
	server := &UserServiceServer{
		listener: ln,
        notifierObservers: make([]UserServiceConnectionCallback, 0),
        disconectionObservers: make([]disconnectionCallback, 0),
	}

	return server
}

func (s *UserServiceServer) SetServerImpl(impl UserServiceServerImpl) {
    s.impl = impl
}

func (s *UserServiceServer) Serve() {
	for {
		conn, err := s.listener.Accept()
		if err != nil {
			fmt.Println("Accept error:", err)
		}

		go s.processConnection(conn)
	}
}

func (s *UserServiceServer) processConnection(conn net.Conn) {
	fmt.Println("Accept connection:", conn.RemoteAddr().String())
	s.emitNewConnectionEvent(conn)
	defer conn.Close()
	defer func() { s.emitDisconnectionEvent(conn) }()

	for {
		reader := bufio.NewReader(conn)
		tp := textproto.NewReader(reader)

		data, err := tp.ReadLine()

		if err != nil {
			fmt.Println("processConnection error", err)
			continue
		}

		fmt.Println("processConnection message", data)
		s.handleCommand(data, conn)
	}
}

func (s *UserServiceServer) handleCommand(payload string, conn net.Conn) {
	recievedMessage := MessageData{}
    json.Unmarshal([]byte(payload), &recievedMessage)
    switch recievedMessage.Endpoint {
        case "UserService.SignIn":
            args := make([]json.RawMessage, 0)
            json.Unmarshal([]byte(recievedMessage.Payload), &args)
            var index int

            var data SignIn
            json.Unmarshal([]byte(args[index]), &data)
            index++

            serverContex := ServerContext{ConnectionAddress: conn.RemoteAddr().String()}
            response := s.impl.SignIn(serverContex,data,)
            bytes, _ := json.Marshal(response)
            messageToSend := recievedMessage
            messageToSend.Payload = string(bytes)
            responseData, _ := json.Marshal(messageToSend)
            conn.Write(responseData)
        case "UserService.SignUp":
            args := make([]json.RawMessage, 0)
            json.Unmarshal([]byte(recievedMessage.Payload), &args)
            var index int

            var data SignUp
            json.Unmarshal([]byte(args[index]), &data)
            index++

            serverContex := ServerContext{ConnectionAddress: conn.RemoteAddr().String()}
            response := s.impl.SignUp(serverContex,data,)
            bytes, _ := json.Marshal(response)
            messageToSend := recievedMessage
            messageToSend.Payload = string(bytes)
            responseData, _ := json.Marshal(messageToSend)
            conn.Write(responseData)
    }
}

// Events
func (s *UserServiceServer) SubscribeToNewConnectionEvent(observer UserServiceConnectionCallback) {
	s.notifierObservers = append(s.notifierObservers, observer)
}

func (s *UserServiceServer) SubscribeToDisconnectionEvent(observer disconnectionCallback) {
	s.disconectionObservers = append(s.disconectionObservers, observer)
}

func (s *UserServiceServer) emitNewConnectionEvent(conn net.Conn) {
	notificator := &UserServiceNotificator{conn: conn}

	for _, callback := range s.notifierObservers {
		callback(conn.RemoteAddr().String(), notificator)
	}
}

func (s *UserServiceServer) emitDisconnectionEvent(conn net.Conn) {
	for _, callback := range s.disconectionObservers {
		callback(conn.RemoteAddr().String())
	}
}


