// Code generated by goqface. DO NOT EDIT.
package chat

import (
    "encoding/json"
    "net"
)

type ChatServiceServerImpl interface {
    SendMessage(message Message,) Status
    GetUserChats(userID string,value int,) []Chat
}

type ChatServiceNotifier interface {
    NotifyMessage(message Message,data string,)
}


type Notificator struct {
	conn net.Conn
}

type connectionCallback = func(string, Notifier)
type disconnectionCallback = func(string)

func(n *Notificator) NotifyMessage(message Message,data string,) {
    args := make([]string, 0)
    var bytes []byte
    bytes, _ = json.Marshal(message)
    args = append(args, string(bytes))
    bytes, _ = json.Marshal(data)
    args = append(args, string(bytes))

    bytes , _ = json.Marshal(args)

    messageToSend := MessageData{}
    messageToSend.Endpoint = "ChatService.NotifyMessage"
    messageToSend.Payload = string(bytes)
    messageToSend.Type = Notification

    payloadToSend, _ := json.Marshal(messageToSend)

    n.conn.Write(payloadToSend)
}


type ChatServiceServer struct {
	listener              net.Listener
	impl                  ChatServiceServerImpl
	notifierObservers     []connectionCallback
	disconectionObservers []disconnectionCallback
}

func NewChatServiceServer(addr string) *ChatServiceServer {
	ln, _ := net.Listen("tcp", addr)
	server := &ChatServiceServer{
		listener: ln,
	}

	return server
}



func (s *ChatServiceServer) Serve() {
	for {
		conn, err := s.listener.Accept()
		if err != nil {
			fmt.Println("Accept error:", err)
		}

		go s.processConnection(conn)
	}
}

func (s *ChatServiceServer) processConnection(conn net.Conn) {
	fmt.Println("Accept connection:", conn.RemoteAddr().String())
	s.emitNewConnectionEvent(conn)
	defer conn.Close()
	defer func() { s.emitDisconnectionEvent(conn) }()

	for {
		reader := bufio.NewReader(conn)
		tp := textproto.NewReader(reader)

		data, err := tp.ReadLine()

		if err != nil {
			fmt.Println("processConnection error", err)
			continue
		}

		fmt.Println("processConnection message", data)
		s.handleCommand(data, conn)
	}
}

func (s *ChatServiceServer) handleCommand(payload string, conn net.Conn) {
	recievedMessage := MessageData{}
    json.Unmarshal([]byte(payload), &recievedMessage)
    switch recievedMessage.Endpoint {
        case "ChatService.SendMessage":
            args := make([]string, 0)
            json.Unmarshal([]byte(recievedMessage.Payload), &args)
            var index int
            var message Message
            json.Unmarshal([]byte(args[index]), &message)
            index = index + 1
            response := s.impl.SendMessage(message,)
            bytes, _ := json.Marshal(response)
            messageToSend := recievedMessage
            messageToSend.Payload = string(bytes)
            responseData, _ := json.Marshal(messageToSend)
            conn.Write(responseData)
        case "ChatService.GetUserChats":
            args := make([]string, 0)
            json.Unmarshal([]byte(recievedMessage.Payload), &args)
            var index int
            var userID string
            json.Unmarshal([]byte(args[index]), &userID)
            index = index + 1
            var value int
            json.Unmarshal([]byte(args[index]), &value)
            index = index + 1
            response := s.impl.GetUserChats(userID,value,)
            bytes, _ := json.Marshal(response)
            messageToSend := recievedMessage
            messageToSend.Payload = string(bytes)
            responseData, _ := json.Marshal(messageToSend)
            conn.Write(responseData)
    }
}

// Events
func (s *ChatServiceServer) SubscribeToNewConnectionEvent(observer connectionCallback) {
	s.notifierObservers = append(s.notifierObservers, observer)
}

func (s *ChatServiceServer) SubscribeToDisconnectionEvent(observer disconnectionCallback) {
	s.disconectionObservers = append(s.disconectionObservers, observer)
}

func (s *ChatServiceServer) emitNewConnectionEvent(conn net.Conn) {
	notificator := &Notificator{conn: conn}

	for _, callback := range s.notifierObservers {
		callback(conn.RemoteAddr().String(), notificator)
	}
}

func (s *ChatServiceServer) emitDisconnectionEvent(conn net.Conn) {
	for _, callback := range s.disconectionObservers {
		callback(conn.RemoteAddr().String())
	}
}