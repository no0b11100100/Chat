// Code generated by goqface. DO NOT EDIT.
package api

import (
    "encoding/json"
    "net"
    "net/textproto"
    "bufio"
    "fmt"
)


//enums
{% for enum in module.enums: %}
type {{enum.name}} int

const (
{% for member in enum.members %}
{{member.unique_name}} = {{member.value}}
{% endfor %}
)
{% endfor %}

//structs
{% for struct in module.structs: %}
type {{struct.name}} struct {
{% for field in struct.fields %}
    {{field.cap_name}} {{field.go_type}} `json:"{{field.cap_name.lower()}}",omitempty bson:"{{field.cap_name.lower()}}"`
{% endfor -%}
}

type {{struct.name}}Tagger struct {
    {% for field in struct.fields %}
    {{field.cap_name}} string
    {% endfor -%}
}

func {{struct.name}}Tags() {{struct.name}}Tagger {
    return {{struct.name}}Tagger {
    {% for field in struct.fields %}
    {{field.cap_name}}: "{{field.cap_name.lower()}}",
    {% endfor -%}
    }
}

{% endfor %}


//server
{% for interface in module.interfaces: %}
type {{interface}}ConnectionCallback = func(string, {{interface}}Notifier)

type {{interface}}ServerImpl interface {
    {% for operation in interface.operations %}
    {{operation.cap_name}}(ServerContext, {%- for parameter in operation.parameters -%}{{parameter.go_type}},{%- endfor -%}) {{operation.go_type}}
    {% endfor %}
}

type {{interface}}Notifier interface {
    {% for signal in interface.signals %}
    {{signal.cap_name}}({%- for parameter in signal.parameters -%}{{parameter.go_type}},{%- endfor -%})
    {% endfor %}
}

type {{interface}}Notificator struct {
	conn net.Conn
}


{% for signal in interface.signals %}
func(n *{{interface}}Notificator) {{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) {
    args := make([]json.RawMessage, 0)
    var bytes []byte
    {%for parameter in signal.parameters%}
    bytes, _ = json.Marshal({{parameter.name}})
    args = append(args, json.RawMessage(bytes))
    {% endfor %}

    bytes , _ = json.Marshal(args)

    messageToSend := MessageData{}
    messageToSend.Endpoint = "{{interface}}.{{signal.cap_name}}"
    messageToSend.Payload = json.RawMessage(bytes)
    messageToSend.Type = Notification

    payloadToSend, _ := json.Marshal(messageToSend)

    n.conn.Write(payloadToSend)
}
{% endfor %}


type {{interface}}Server struct {
	listener              net.Listener
	impl                  {{interface}}ServerImpl
	notifierObservers     []{{interface}}ConnectionCallback
	disconectionObservers []disconnectionCallback
}

func New{{interface}}Server(addr string) *{{interface}}Server {
	ln, _ := net.Listen("tcp", addr)
	server := &{{interface}}Server{
		listener: ln,
        notifierObservers: make([]{{interface}}ConnectionCallback, 0),
        disconectionObservers: make([]disconnectionCallback, 0),
	}

	return server
}

func (s *{{interface}}Server) Stop() {
    if err := s.listener.Close(); err != nil {
        fmt.Println("{{interface}}Server Stop error:", err)
    }
}

func (s *{{interface}}Server) SetServerImpl(impl {{interface}}ServerImpl) {
    s.impl = impl
}

func (s *{{interface}}Server) Serve() {
	for {
		conn, err := s.listener.Accept()
		if err != nil {
			fmt.Println("Accept error:", err)
		}

		go s.processConnection(conn)
	}
}

func (s *{{interface}}Server) processConnection(conn net.Conn) {
	fmt.Println("Accept connection in {{interface}}Server:", conn.RemoteAddr().String())
	s.emitNewConnectionEvent(conn)
	defer conn.Close()
	defer func() { s.emitDisconnectionEvent(conn) }()

	for {
		reader := bufio.NewReader(conn)
		tp := textproto.NewReader(reader)

		data, err := tp.ReadLine()

		if err != nil {
			fmt.Println("processConnection error", err)
			break
		}

		fmt.Println("processConnection message", data)
		s.handleCommand(data, conn)
	}
}

func (s *{{interface}}Server) handleCommand(payload string, conn net.Conn) {
	recievedMessage := MessageData{}
    json.Unmarshal([]byte(payload), &recievedMessage)
    switch recievedMessage.Endpoint {
        {% for operation in interface.operations %}
        case "{{interface}}.{{operation.cap_name}}":
            args := make([]json.RawMessage, 0)
            json.Unmarshal(recievedMessage.Payload, &args)
            var index int
            {% for parameter in operation.parameters %}

            var {{parameter.name}} {{parameter.go_type}}
            json.Unmarshal(args[index], &{{parameter.name}})
            index++

            {% endfor %}
            serverContex := ServerContext{ConnectionAddress: conn.RemoteAddr().String()}
            response := s.impl.{{operation.cap_name}}(serverContex, {%- for parameter in operation.parameters -%} {{parameter.name}},{%- endfor -%})
            bytes, _ := json.Marshal(response)
            messageToSend := recievedMessage
            messageToSend.Payload = json.RawMessage(bytes)
            responseData, _ := json.Marshal(messageToSend)
            conn.Write(responseData)
        {% endfor %}
    }
}

// Events
func (s *{{interface}}Server) SubscribeToNewConnectionEvent(observer {{interface}}ConnectionCallback) {
	s.notifierObservers = append(s.notifierObservers, observer)
}

func (s *{{interface}}Server) SubscribeToDisconnectionEvent(observer disconnectionCallback) {
	s.disconectionObservers = append(s.disconectionObservers, observer)
}

func (s *{{interface}}Server) emitNewConnectionEvent(conn net.Conn) {
	notificator := &{{interface}}Notificator{conn: conn}

	for _, callback := range s.notifierObservers {
		callback(conn.RemoteAddr().String(), notificator)
	}
}

func (s *{{interface}}Server) emitDisconnectionEvent(conn net.Conn) {
	for _, callback := range s.disconectionObservers {
		callback(conn.RemoteAddr().String())
	}
}


{% endfor %}
