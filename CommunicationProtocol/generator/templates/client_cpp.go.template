#pragma once

#include <string>
#include <vector>
#include <functional>
#include <algothm>
#include <memory>
#include <future>
#include <unordered_map>
#include <chrono>

//enums
{% for enum in module.enums: %}
enum class {{enum.name}}
{
    {% for member in enum.members %}
    {{member.unique_name}} = {{member.value}}
    {% endfor %}
};

{% endfor %}

//structs
{% for struct in module.structs: %}
struct {{struct.name}} : public ClassParser
{
{% for field in struct.fields %}
    {{field.cpp_type}} {{field.cap_name}};
{% endfor -%}

    virtual Value toJson() override
    {
        Value js({});
        {% for field in struct.fields %}
        js["{{field.cap_name}}"] = {{field.cap_name}};
        {% endfor -%}
        return js;
    }

    virtual void fromJson(Value js) override
    {
        {% for field in struct.fields %}
        {{field.cap_name}} = js["{{field.cap_name}}"];
        {% endfor -%}
    }
};

{% endfor %}

//client
class Waiter
{
    int m_topic;
    std::promise<std::string> m_response;
public:
    Waiter(int topicID)
    : m_topic{topicID}
    {}

    bool IsTopic(int topic) const { return m_topic == topic; }

    void SetResponse(std::string response)
    {
        m_response.set_value(response);
    }

    template<class T>
    T GetData()
    {
        auto future = m_response.get_future();
        auto response_paylaod = future.get();
        json response = json::parse(response_paylaod);
        T result;
        result = response;
        return result;
    }

    //TODO
    template<void>
    void GetData()
    {}
};


class Base
{
    std::unique_ptr<Client> m_connection;
    std::unordered_map<std::string, std::function<void(std::string)>> m_signals;
public:
    Base(const std::string& addr)
     : m_connection{new Client([this](const std::string& s){handleServerMessage(s);})}
    {
        m_connection->connectToServer();
    }

    const Waiter& Request(MessageData& message)
    {
        message.Topic = std::to_string(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
        m_connection->sendPayload(message.toJson().dump());
        w = Waiter(message.Topic);
        waiters.push_back(w);
        return waiters.back();
    }

private:
    void handleServerMessage(const std::string& message)
    {
        json js = json::parse(payload);
        MessageData data;
        data = js;
        if (data.type == Notification) {
            auto result = isSignalHandlable(data.Endpoint);
            if(result.has_value())
            {
                auto handler = result.value();
                handler(data.Payload);
            }
        }
        else
        {
            for(auto& waiter : waiters)
            {
                if waiter.IsTopic(data.Topic) {
                    waiter.SetResponse(data.Payload);
                    break;
                }
            }
        }

    }

    std::optional<std::function<void(std::string)>> isSignalHandlable(const std::string& name)
    {
        auto it = std::find_if(m_signals.begin(), m_signals.end(), [&name](const std::pair<std::string, std::function<void(std::string)>>& p)
        {
            return p.first == name;
        });
        if (it != m_signals.end())
            return std::optional<std::function<void(std::string)>>{[this, name](const std::string& payload){ handle(name, payload); }};
        return std::nullopt;
    }

    void handle(const std::string& name, const std::string& payload)
    {
        m_signals.at(name)(paylaod);
    }

protected:
    void addSignalHandler(std::string name, std::function<void(std::string)> handler)
    {
        m_signals.emplace(name, handler);
    }
};

{% for interface in module.interfaces: %}

class {{interface}}Stub : Base
{
    {% for signal in interface.signals %}
    std::vector<std::function<void({%- for parameter in signal.parameters -%}  {{parameter.cpp_type}} {{parameter.name}},{%- endfor -%})>> m_{{signal.cap_name}}Callbacks;
    {% endfor %}
public:
    ChatService(const std::string& addr)
        : Base(addr)
    {
        {% for signal in interface.signals %}
        addSignalHandler("{{interface}}.{{signal.cap_name}}", [this](std::string payload){ on{{signal.cap_name}}(payload); })
        {% endfor %}
    }

    {% for signal in interface.signals %}
    void SubscribeTo{{signal.cap_name}}Event(std::function<void({%- for parameter in signal.parameters -%}  {{parameter.cpp_type}} {{parameter.name}},{%- endfor -%})> callback)
    {
        m_{{signal.cap_name}}Callbacks.push_back(callback);
    }
    {% endfor %}

    {% for operation in interface.operations %}
    {{operation.cpp_type}} {{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}} {{parameter.go_type}},{%- endfor -%})
    {
        json args = json::array({ {%- for parameter in operation.parameters -%}{{parameter.name}} {{parameter.go_type}},{%- endfor -%} });
        MessageData message;
        message.Endpoint = "{{interface}}.{{operation.cap_name}}";
        message.Payload = args.dump();
        return Request(message).GetData<{{operation.cpp_type}}>();
    }
    {% endfor %}

private:
    {% for signal in interface.signals %}
    void on{{signal.cap_name}}(const std::string& payload)
    {
        json response = json::parse(payload);
        int i = 0;
        {% for parameter in signal.parameters %}
        {{parameter.cpp_type}} {{parameter.name}} = response[i];
        ++i;
        {% endfor %}

        for(const auto& call : m_{{signal.cap_name}}Callbacks)
        {
            call({%- for parameter in signal.parameters -%}  {{parameter.cpp_type}} {{parameter.name}},{%- endfor -%});
        }
    }
    {% endfor %}
};
{% endfor %}