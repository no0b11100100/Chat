#pragma once

#include "common.hpp"

{% for import in module.imports: %}
    #include "{{import.split()[0]}}.hpp"
{% endfor %}

namespace {{module.module.name_parts[-1]}} {

//enums
{% for enum in module.enums: %}
enum class {{enum.name}}
{ {% for member in enum.members %}{{member.unique_name}} = {{member.value}},{% endfor %}};

{% endfor %}

//structs
{% for struct in module.structs: %}
struct {{struct.name}} : public Types::ClassParser
{
{% for field in struct.fields %}
    {{field.cpp_type}} {{field.cap_name}};
{% endfor -%}

    virtual json toJson() const override
    {
        json js({});
        {% for field in struct.fields %}
        js["{{field.cap_name}}"] = {{field.cap_name}};
        {% endfor -%}
        return js;
    }

    virtual void fromJson(json js) override
    {
        {% for field in struct.fields %}
        if(js.isNull()) {{field.cap_name}} = {{field.cpp_type}}();
        else {{field.cap_name}} = static_cast<{{field.cpp_type}}>(js["{{field.cap_name}}"]);
        {% endfor -%}
    }
};

{% endfor %}

{% for interface in module.interfaces: %}

class {{interface}}Stub : public Common::Base
{
    {% for signal in interface.signals %}
    std::vector<std::function<void({%- for parameter in signal.parameters -%}  {{parameter.cpp_type}},{%- endfor -%})>> m_{{signal.cap_name}}Callbacks;
    {% endfor %}
public:
    {{interface}}Stub() = default;

    {{interface}}Stub(const std::string& addr)
        : Common::Base(addr)
    {
        {% for signal in interface.signals %}
        addSignalHandler("{{interface}}.{{signal.cap_name}}", [this](json payload){ on{{signal.cap_name}}(payload); });
        {% endfor %}
    }

    {% for signal in interface.signals %}
    void SubscribeTo{{signal.cap_name}}Event(std::function<void({%- for parameter in signal.parameters -%}  {{parameter.cpp_type}} {{parameter.name}},{%- endfor -%})> callback)
    {
        m_{{signal.cap_name}}Callbacks.push_back(callback);
    }
    {% endfor %}

    {% for operation in interface.operations %}
    {{operation.cpp_type}} {{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.cpp_type}} {{parameter.name}},{%- endfor -%})
    {
        Common::MessageData _message;
        _message.Payload = json::array({ {%- for parameter in operation.parameters -%}{{parameter.name}},{%- endfor -%} });
        _message.Endpoint = "{{interface}}.{{operation.cap_name}}";
        return Request<{{operation.cpp_type}}>(_message);
    }
    {% endfor %}

private:
    {% for signal in interface.signals %}
    void on{{signal.cap_name}}(json response)
    {
        int i = 0;
        {% for parameter in signal.parameters %}
        {{parameter.cpp_type}} {{parameter.name}} = response[i];
        ++i;
        {% endfor %}

        for(const auto& call : m_{{signal.cap_name}}Callbacks)
        {
            call({%- for parameter in signal.parameters -%} {{parameter.name}},{%- endfor -%});
        }
    }
    {% endfor %}
};
{% endfor %}

};