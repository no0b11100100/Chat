// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chat_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chat_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chat_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chat_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chat_5fservice_2eproto;
namespace chat {
class ChatData;
struct ChatDataDefaultTypeInternal;
extern ChatDataDefaultTypeInternal _ChatData_default_instance_;
class ChatInfo;
struct ChatInfoDefaultTypeInternal;
extern ChatInfoDefaultTypeInternal _ChatInfo_default_instance_;
class Chats;
struct ChatsDefaultTypeInternal;
extern ChatsDefaultTypeInternal _Chats_default_instance_;
class ExchangedMessage;
struct ExchangedMessageDefaultTypeInternal;
extern ExchangedMessageDefaultTypeInternal _ExchangedMessage_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MessageChan;
struct MessageChanDefaultTypeInternal;
extern MessageChanDefaultTypeInternal _MessageChan_default_instance_;
class MessageID;
struct MessageIDDefaultTypeInternal;
extern MessageIDDefaultTypeInternal _MessageID_default_instance_;
class Messages;
struct MessagesDefaultTypeInternal;
extern MessagesDefaultTypeInternal _Messages_default_instance_;
class ReadMessage;
struct ReadMessageDefaultTypeInternal;
extern ReadMessageDefaultTypeInternal _ReadMessage_default_instance_;
class UserID;
struct UserIDDefaultTypeInternal;
extern UserIDDefaultTypeInternal _UserID_default_instance_;
}  // namespace chat
PROTOBUF_NAMESPACE_OPEN
template<> ::chat::ChatData* Arena::CreateMaybeMessage<::chat::ChatData>(Arena*);
template<> ::chat::ChatInfo* Arena::CreateMaybeMessage<::chat::ChatInfo>(Arena*);
template<> ::chat::Chats* Arena::CreateMaybeMessage<::chat::Chats>(Arena*);
template<> ::chat::ExchangedMessage* Arena::CreateMaybeMessage<::chat::ExchangedMessage>(Arena*);
template<> ::chat::Message* Arena::CreateMaybeMessage<::chat::Message>(Arena*);
template<> ::chat::MessageChan* Arena::CreateMaybeMessage<::chat::MessageChan>(Arena*);
template<> ::chat::MessageID* Arena::CreateMaybeMessage<::chat::MessageID>(Arena*);
template<> ::chat::Messages* Arena::CreateMaybeMessage<::chat::Messages>(Arena*);
template<> ::chat::ReadMessage* Arena::CreateMaybeMessage<::chat::ReadMessage>(Arena*);
template<> ::chat::UserID* Arena::CreateMaybeMessage<::chat::UserID>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chat {

enum Direction : int {
  Forward = 0,
  Backward = 1,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = Forward;
constexpr Direction Direction_MAX = Backward;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
enum MessageType : int {
  Normal = 0,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = Normal;
constexpr MessageType MessageType_MAX = Normal;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class ChatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChatInfo) */ {
 public:
  inline ChatInfo() : ChatInfo(nullptr) {}
  ~ChatInfo() override;
  explicit PROTOBUF_CONSTEXPR ChatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatInfo(const ChatInfo& from);
  ChatInfo(ChatInfo&& from) noexcept
    : ChatInfo() {
    *this = ::std::move(from);
  }

  inline ChatInfo& operator=(const ChatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatInfo& operator=(ChatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatInfo* internal_default_instance() {
    return reinterpret_cast<const ChatInfo*>(
               &_ChatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChatInfo& a, ChatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatInfo& from) {
    ChatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatInfo";
  }
  protected:
  explicit ChatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 7,
    kChatIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kSecondLineFieldNumber = 3,
    kLastMessageFieldNumber = 4,
    kCoverFieldNumber = 6,
    kMessagesFieldNumber = 8,
    kUnreadedCountFieldNumber = 5,
  };
  // repeated string participants = 7;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  const std::string& participants(int index) const;
  std::string* mutable_participants(int index);
  void set_participants(int index, const std::string& value);
  void set_participants(int index, std::string&& value);
  void set_participants(int index, const char* value);
  void set_participants(int index, const char* value, size_t size);
  std::string* add_participants();
  void add_participants(const std::string& value);
  void add_participants(std::string&& value);
  void add_participants(const char* value);
  void add_participants(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& participants() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_participants();
  private:
  const std::string& _internal_participants(int index) const;
  std::string* _internal_add_participants();
  public:

  // string chat_id = 1;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string secondLine = 3;
  void clear_secondline();
  const std::string& secondline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secondline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secondline();
  PROTOBUF_NODISCARD std::string* release_secondline();
  void set_allocated_secondline(std::string* secondline);
  private:
  const std::string& _internal_secondline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secondline(const std::string& value);
  std::string* _internal_mutable_secondline();
  public:

  // string lastMessage = 4;
  void clear_lastmessage();
  const std::string& lastmessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lastmessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lastmessage();
  PROTOBUF_NODISCARD std::string* release_lastmessage();
  void set_allocated_lastmessage(std::string* lastmessage);
  private:
  const std::string& _internal_lastmessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lastmessage(const std::string& value);
  std::string* _internal_mutable_lastmessage();
  public:

  // string cover = 6;
  void clear_cover();
  const std::string& cover() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cover(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cover();
  PROTOBUF_NODISCARD std::string* release_cover();
  void set_allocated_cover(std::string* cover);
  private:
  const std::string& _internal_cover() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cover(const std::string& value);
  std::string* _internal_mutable_cover();
  public:

  // .chat.Messages messages = 8;
  bool has_messages() const;
  private:
  bool _internal_has_messages() const;
  public:
  void clear_messages();
  const ::chat::Messages& messages() const;
  PROTOBUF_NODISCARD ::chat::Messages* release_messages();
  ::chat::Messages* mutable_messages();
  void set_allocated_messages(::chat::Messages* messages);
  private:
  const ::chat::Messages& _internal_messages() const;
  ::chat::Messages* _internal_mutable_messages();
  public:
  void unsafe_arena_set_allocated_messages(
      ::chat::Messages* messages);
  ::chat::Messages* unsafe_arena_release_messages();

  // int64 unreadedCount = 5;
  void clear_unreadedcount();
  int64_t unreadedcount() const;
  void set_unreadedcount(int64_t value);
  private:
  int64_t _internal_unreadedcount() const;
  void _internal_set_unreadedcount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:chat.ChatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> participants_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secondline_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lastmessage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cover_;
    ::chat::Messages* messages_;
    int64_t unreadedcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Chats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.Chats) */ {
 public:
  inline Chats() : Chats(nullptr) {}
  ~Chats() override;
  explicit PROTOBUF_CONSTEXPR Chats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chats(const Chats& from);
  Chats(Chats&& from) noexcept
    : Chats() {
    *this = ::std::move(from);
  }

  inline Chats& operator=(const Chats& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chats& operator=(Chats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chats& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chats* internal_default_instance() {
    return reinterpret_cast<const Chats*>(
               &_Chats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Chats& a, Chats& b) {
    a.Swap(&b);
  }
  inline void Swap(Chats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Chats& from) {
    Chats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.Chats";
  }
  protected:
  explicit Chats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatsFieldNumber = 1,
  };
  // repeated .chat.ChatInfo chats = 1;
  int chats_size() const;
  private:
  int _internal_chats_size() const;
  public:
  void clear_chats();
  ::chat::ChatInfo* mutable_chats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ChatInfo >*
      mutable_chats();
  private:
  const ::chat::ChatInfo& _internal_chats(int index) const;
  ::chat::ChatInfo* _internal_add_chats();
  public:
  const ::chat::ChatInfo& chats(int index) const;
  ::chat::ChatInfo* add_chats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ChatInfo >&
      chats() const;

  // @@protoc_insertion_point(class_scope:chat.Chats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ChatInfo > chats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class MessageChan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.MessageChan) */ {
 public:
  inline MessageChan() : MessageChan(nullptr) {}
  ~MessageChan() override;
  explicit PROTOBUF_CONSTEXPR MessageChan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageChan(const MessageChan& from);
  MessageChan(MessageChan&& from) noexcept
    : MessageChan() {
    *this = ::std::move(from);
  }

  inline MessageChan& operator=(const MessageChan& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageChan& operator=(MessageChan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageChan& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageChan* internal_default_instance() {
    return reinterpret_cast<const MessageChan*>(
               &_MessageChan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MessageChan& a, MessageChan& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageChan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageChan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageChan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageChan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageChan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageChan& from) {
    MessageChan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageChan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.MessageChan";
  }
  protected:
  explicit MessageChan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kChatIdFieldNumber = 3,
    kDirectionFieldNumber = 2,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string chat_id = 3;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // .chat.Direction direction = 2;
  void clear_direction();
  ::chat::Direction direction() const;
  void set_direction(::chat::Direction value);
  private:
  ::chat::Direction _internal_direction() const;
  void _internal_set_direction(::chat::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:chat.MessageChan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageJsonFieldNumber = 2,
    kMessageTypeFieldNumber = 1,
  };
  // string message_json = 2;
  void clear_message_json();
  const std::string& message_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_json();
  PROTOBUF_NODISCARD std::string* release_message_json();
  void set_allocated_message_json(std::string* message_json);
  private:
  const std::string& _internal_message_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_json(const std::string& value);
  std::string* _internal_mutable_message_json();
  public:

  // .chat.MessageType messageType = 1;
  void clear_messagetype();
  ::chat::MessageType messagetype() const;
  void set_messagetype(::chat::MessageType value);
  private:
  ::chat::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::chat::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:chat.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_json_;
    int messagetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Messages final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.Messages) */ {
 public:
  inline Messages() : Messages(nullptr) {}
  ~Messages() override;
  explicit PROTOBUF_CONSTEXPR Messages(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Messages(const Messages& from);
  Messages(Messages&& from) noexcept
    : Messages() {
    *this = ::std::move(from);
  }

  inline Messages& operator=(const Messages& from) {
    CopyFrom(from);
    return *this;
  }
  inline Messages& operator=(Messages&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Messages& default_instance() {
    return *internal_default_instance();
  }
  static inline const Messages* internal_default_instance() {
    return reinterpret_cast<const Messages*>(
               &_Messages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Messages& a, Messages& b) {
    a.Swap(&b);
  }
  inline void Swap(Messages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Messages* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Messages* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Messages>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Messages& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Messages& from) {
    Messages::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Messages* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.Messages";
  }
  protected:
  explicit Messages(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .chat.Message messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::chat::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::Message >*
      mutable_messages();
  private:
  const ::chat::Message& _internal_messages(int index) const;
  ::chat::Message* _internal_add_messages();
  public:
  const ::chat::Message& messages(int index) const;
  ::chat::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::Message >&
      messages() const;

  // @@protoc_insertion_point(class_scope:chat.Messages)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::Message > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UserID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.UserID) */ {
 public:
  inline UserID() : UserID(nullptr) {}
  ~UserID() override;
  explicit PROTOBUF_CONSTEXPR UserID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserID(const UserID& from);
  UserID(UserID&& from) noexcept
    : UserID() {
    *this = ::std::move(from);
  }

  inline UserID& operator=(const UserID& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserID& operator=(UserID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserID& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserID* internal_default_instance() {
    return reinterpret_cast<const UserID*>(
               &_UserID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UserID& a, UserID& b) {
    a.Swap(&b);
  }
  inline void Swap(UserID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserID& from) {
    UserID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.UserID";
  }
  protected:
  explicit UserID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:chat.UserID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class MessageID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.MessageID) */ {
 public:
  inline MessageID() : MessageID(nullptr) {}
  ~MessageID() override;
  explicit PROTOBUF_CONSTEXPR MessageID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageID(const MessageID& from);
  MessageID(MessageID&& from) noexcept
    : MessageID() {
    *this = ::std::move(from);
  }

  inline MessageID& operator=(const MessageID& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageID& operator=(MessageID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageID& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageID* internal_default_instance() {
    return reinterpret_cast<const MessageID*>(
               &_MessageID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MessageID& a, MessageID& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageID& from) {
    MessageID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.MessageID";
  }
  protected:
  explicit MessageID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // @@protoc_insertion_point(class_scope:chat.MessageID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ChatData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChatData) */ {
 public:
  inline ChatData() : ChatData(nullptr) {}
  ~ChatData() override;
  explicit PROTOBUF_CONSTEXPR ChatData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatData(const ChatData& from);
  ChatData(ChatData&& from) noexcept
    : ChatData() {
    *this = ::std::move(from);
  }

  inline ChatData& operator=(const ChatData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatData& operator=(ChatData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatData* internal_default_instance() {
    return reinterpret_cast<const ChatData*>(
               &_ChatData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChatData& a, ChatData& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatData& from) {
    ChatData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChatData";
  }
  protected:
  explicit ChatData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonFieldNumber = 1,
  };
  // string json = 1;
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  // @@protoc_insertion_point(class_scope:chat.ChatData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ExchangedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ExchangedMessage) */ {
 public:
  inline ExchangedMessage() : ExchangedMessage(nullptr) {}
  ~ExchangedMessage() override;
  explicit PROTOBUF_CONSTEXPR ExchangedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangedMessage(const ExchangedMessage& from);
  ExchangedMessage(ExchangedMessage&& from) noexcept
    : ExchangedMessage() {
    *this = ::std::move(from);
  }

  inline ExchangedMessage& operator=(const ExchangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangedMessage& operator=(ExchangedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangedMessage* internal_default_instance() {
    return reinterpret_cast<const ExchangedMessage*>(
               &_ExchangedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ExchangedMessage& a, ExchangedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExchangedMessage& from) {
    ExchangedMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ExchangedMessage";
  }
  protected:
  explicit ExchangedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatIdFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string chat_id = 1;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // .chat.Message message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::chat::Message& message() const;
  PROTOBUF_NODISCARD ::chat::Message* release_message();
  ::chat::Message* mutable_message();
  void set_allocated_message(::chat::Message* message);
  private:
  const ::chat::Message& _internal_message() const;
  ::chat::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::chat::Message* message);
  ::chat::Message* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:chat.ExchangedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::chat::Message* message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReadMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ReadMessage) */ {
 public:
  inline ReadMessage() : ReadMessage(nullptr) {}
  ~ReadMessage() override;
  explicit PROTOBUF_CONSTEXPR ReadMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadMessage(const ReadMessage& from);
  ReadMessage(ReadMessage&& from) noexcept
    : ReadMessage() {
    *this = ::std::move(from);
  }

  inline ReadMessage& operator=(const ReadMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadMessage& operator=(ReadMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadMessage* internal_default_instance() {
    return reinterpret_cast<const ReadMessage*>(
               &_ReadMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReadMessage& a, ReadMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadMessage& from) {
    ReadMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ReadMessage";
  }
  protected:
  explicit ReadMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatIdFieldNumber = 1,
    kMessageIdFieldNumber = 2,
  };
  // string chat_id = 1;
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // string message_id = 2;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // @@protoc_insertion_point(class_scope:chat.ReadMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChatInfo

// string chat_id = 1;
inline void ChatInfo::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& ChatInfo::chat_id() const {
  // @@protoc_insertion_point(field_get:chat.ChatInfo.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatInfo::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChatInfo.chat_id)
}
inline std::string* ChatInfo::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:chat.ChatInfo.chat_id)
  return _s;
}
inline const std::string& ChatInfo::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void ChatInfo::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatInfo::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatInfo::release_chat_id() {
  // @@protoc_insertion_point(field_release:chat.ChatInfo.chat_id)
  return _impl_.chat_id_.Release();
}
inline void ChatInfo::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChatInfo.chat_id)
}

// string title = 2;
inline void ChatInfo::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ChatInfo::title() const {
  // @@protoc_insertion_point(field_get:chat.ChatInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatInfo::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChatInfo.title)
}
inline std::string* ChatInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:chat.ChatInfo.title)
  return _s;
}
inline const std::string& ChatInfo::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ChatInfo::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatInfo::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatInfo::release_title() {
  // @@protoc_insertion_point(field_release:chat.ChatInfo.title)
  return _impl_.title_.Release();
}
inline void ChatInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChatInfo.title)
}

// string secondLine = 3;
inline void ChatInfo::clear_secondline() {
  _impl_.secondline_.ClearToEmpty();
}
inline const std::string& ChatInfo::secondline() const {
  // @@protoc_insertion_point(field_get:chat.ChatInfo.secondLine)
  return _internal_secondline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatInfo::set_secondline(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secondline_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChatInfo.secondLine)
}
inline std::string* ChatInfo::mutable_secondline() {
  std::string* _s = _internal_mutable_secondline();
  // @@protoc_insertion_point(field_mutable:chat.ChatInfo.secondLine)
  return _s;
}
inline const std::string& ChatInfo::_internal_secondline() const {
  return _impl_.secondline_.Get();
}
inline void ChatInfo::_internal_set_secondline(const std::string& value) {
  
  _impl_.secondline_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatInfo::_internal_mutable_secondline() {
  
  return _impl_.secondline_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatInfo::release_secondline() {
  // @@protoc_insertion_point(field_release:chat.ChatInfo.secondLine)
  return _impl_.secondline_.Release();
}
inline void ChatInfo::set_allocated_secondline(std::string* secondline) {
  if (secondline != nullptr) {
    
  } else {
    
  }
  _impl_.secondline_.SetAllocated(secondline, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secondline_.IsDefault()) {
    _impl_.secondline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChatInfo.secondLine)
}

// string lastMessage = 4;
inline void ChatInfo::clear_lastmessage() {
  _impl_.lastmessage_.ClearToEmpty();
}
inline const std::string& ChatInfo::lastmessage() const {
  // @@protoc_insertion_point(field_get:chat.ChatInfo.lastMessage)
  return _internal_lastmessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatInfo::set_lastmessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lastmessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChatInfo.lastMessage)
}
inline std::string* ChatInfo::mutable_lastmessage() {
  std::string* _s = _internal_mutable_lastmessage();
  // @@protoc_insertion_point(field_mutable:chat.ChatInfo.lastMessage)
  return _s;
}
inline const std::string& ChatInfo::_internal_lastmessage() const {
  return _impl_.lastmessage_.Get();
}
inline void ChatInfo::_internal_set_lastmessage(const std::string& value) {
  
  _impl_.lastmessage_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatInfo::_internal_mutable_lastmessage() {
  
  return _impl_.lastmessage_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatInfo::release_lastmessage() {
  // @@protoc_insertion_point(field_release:chat.ChatInfo.lastMessage)
  return _impl_.lastmessage_.Release();
}
inline void ChatInfo::set_allocated_lastmessage(std::string* lastmessage) {
  if (lastmessage != nullptr) {
    
  } else {
    
  }
  _impl_.lastmessage_.SetAllocated(lastmessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lastmessage_.IsDefault()) {
    _impl_.lastmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChatInfo.lastMessage)
}

// int64 unreadedCount = 5;
inline void ChatInfo::clear_unreadedcount() {
  _impl_.unreadedcount_ = int64_t{0};
}
inline int64_t ChatInfo::_internal_unreadedcount() const {
  return _impl_.unreadedcount_;
}
inline int64_t ChatInfo::unreadedcount() const {
  // @@protoc_insertion_point(field_get:chat.ChatInfo.unreadedCount)
  return _internal_unreadedcount();
}
inline void ChatInfo::_internal_set_unreadedcount(int64_t value) {
  
  _impl_.unreadedcount_ = value;
}
inline void ChatInfo::set_unreadedcount(int64_t value) {
  _internal_set_unreadedcount(value);
  // @@protoc_insertion_point(field_set:chat.ChatInfo.unreadedCount)
}

// string cover = 6;
inline void ChatInfo::clear_cover() {
  _impl_.cover_.ClearToEmpty();
}
inline const std::string& ChatInfo::cover() const {
  // @@protoc_insertion_point(field_get:chat.ChatInfo.cover)
  return _internal_cover();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatInfo::set_cover(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cover_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChatInfo.cover)
}
inline std::string* ChatInfo::mutable_cover() {
  std::string* _s = _internal_mutable_cover();
  // @@protoc_insertion_point(field_mutable:chat.ChatInfo.cover)
  return _s;
}
inline const std::string& ChatInfo::_internal_cover() const {
  return _impl_.cover_.Get();
}
inline void ChatInfo::_internal_set_cover(const std::string& value) {
  
  _impl_.cover_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatInfo::_internal_mutable_cover() {
  
  return _impl_.cover_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatInfo::release_cover() {
  // @@protoc_insertion_point(field_release:chat.ChatInfo.cover)
  return _impl_.cover_.Release();
}
inline void ChatInfo::set_allocated_cover(std::string* cover) {
  if (cover != nullptr) {
    
  } else {
    
  }
  _impl_.cover_.SetAllocated(cover, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cover_.IsDefault()) {
    _impl_.cover_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChatInfo.cover)
}

// repeated string participants = 7;
inline int ChatInfo::_internal_participants_size() const {
  return _impl_.participants_.size();
}
inline int ChatInfo::participants_size() const {
  return _internal_participants_size();
}
inline void ChatInfo::clear_participants() {
  _impl_.participants_.Clear();
}
inline std::string* ChatInfo::add_participants() {
  std::string* _s = _internal_add_participants();
  // @@protoc_insertion_point(field_add_mutable:chat.ChatInfo.participants)
  return _s;
}
inline const std::string& ChatInfo::_internal_participants(int index) const {
  return _impl_.participants_.Get(index);
}
inline const std::string& ChatInfo::participants(int index) const {
  // @@protoc_insertion_point(field_get:chat.ChatInfo.participants)
  return _internal_participants(index);
}
inline std::string* ChatInfo::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:chat.ChatInfo.participants)
  return _impl_.participants_.Mutable(index);
}
inline void ChatInfo::set_participants(int index, const std::string& value) {
  _impl_.participants_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:chat.ChatInfo.participants)
}
inline void ChatInfo::set_participants(int index, std::string&& value) {
  _impl_.participants_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:chat.ChatInfo.participants)
}
inline void ChatInfo::set_participants(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participants_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chat.ChatInfo.participants)
}
inline void ChatInfo::set_participants(int index, const char* value, size_t size) {
  _impl_.participants_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chat.ChatInfo.participants)
}
inline std::string* ChatInfo::_internal_add_participants() {
  return _impl_.participants_.Add();
}
inline void ChatInfo::add_participants(const std::string& value) {
  _impl_.participants_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chat.ChatInfo.participants)
}
inline void ChatInfo::add_participants(std::string&& value) {
  _impl_.participants_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chat.ChatInfo.participants)
}
inline void ChatInfo::add_participants(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participants_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chat.ChatInfo.participants)
}
inline void ChatInfo::add_participants(const char* value, size_t size) {
  _impl_.participants_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chat.ChatInfo.participants)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ChatInfo::participants() const {
  // @@protoc_insertion_point(field_list:chat.ChatInfo.participants)
  return _impl_.participants_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ChatInfo::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:chat.ChatInfo.participants)
  return &_impl_.participants_;
}

// .chat.Messages messages = 8;
inline bool ChatInfo::_internal_has_messages() const {
  return this != internal_default_instance() && _impl_.messages_ != nullptr;
}
inline bool ChatInfo::has_messages() const {
  return _internal_has_messages();
}
inline void ChatInfo::clear_messages() {
  if (GetArenaForAllocation() == nullptr && _impl_.messages_ != nullptr) {
    delete _impl_.messages_;
  }
  _impl_.messages_ = nullptr;
}
inline const ::chat::Messages& ChatInfo::_internal_messages() const {
  const ::chat::Messages* p = _impl_.messages_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::Messages&>(
      ::chat::_Messages_default_instance_);
}
inline const ::chat::Messages& ChatInfo::messages() const {
  // @@protoc_insertion_point(field_get:chat.ChatInfo.messages)
  return _internal_messages();
}
inline void ChatInfo::unsafe_arena_set_allocated_messages(
    ::chat::Messages* messages) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.messages_);
  }
  _impl_.messages_ = messages;
  if (messages) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ChatInfo.messages)
}
inline ::chat::Messages* ChatInfo::release_messages() {
  
  ::chat::Messages* temp = _impl_.messages_;
  _impl_.messages_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::Messages* ChatInfo::unsafe_arena_release_messages() {
  // @@protoc_insertion_point(field_release:chat.ChatInfo.messages)
  
  ::chat::Messages* temp = _impl_.messages_;
  _impl_.messages_ = nullptr;
  return temp;
}
inline ::chat::Messages* ChatInfo::_internal_mutable_messages() {
  
  if (_impl_.messages_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::Messages>(GetArenaForAllocation());
    _impl_.messages_ = p;
  }
  return _impl_.messages_;
}
inline ::chat::Messages* ChatInfo::mutable_messages() {
  ::chat::Messages* _msg = _internal_mutable_messages();
  // @@protoc_insertion_point(field_mutable:chat.ChatInfo.messages)
  return _msg;
}
inline void ChatInfo::set_allocated_messages(::chat::Messages* messages) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.messages_;
  }
  if (messages) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(messages);
    if (message_arena != submessage_arena) {
      messages = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, messages, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.messages_ = messages;
  // @@protoc_insertion_point(field_set_allocated:chat.ChatInfo.messages)
}

// -------------------------------------------------------------------

// Chats

// repeated .chat.ChatInfo chats = 1;
inline int Chats::_internal_chats_size() const {
  return _impl_.chats_.size();
}
inline int Chats::chats_size() const {
  return _internal_chats_size();
}
inline void Chats::clear_chats() {
  _impl_.chats_.Clear();
}
inline ::chat::ChatInfo* Chats::mutable_chats(int index) {
  // @@protoc_insertion_point(field_mutable:chat.Chats.chats)
  return _impl_.chats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ChatInfo >*
Chats::mutable_chats() {
  // @@protoc_insertion_point(field_mutable_list:chat.Chats.chats)
  return &_impl_.chats_;
}
inline const ::chat::ChatInfo& Chats::_internal_chats(int index) const {
  return _impl_.chats_.Get(index);
}
inline const ::chat::ChatInfo& Chats::chats(int index) const {
  // @@protoc_insertion_point(field_get:chat.Chats.chats)
  return _internal_chats(index);
}
inline ::chat::ChatInfo* Chats::_internal_add_chats() {
  return _impl_.chats_.Add();
}
inline ::chat::ChatInfo* Chats::add_chats() {
  ::chat::ChatInfo* _add = _internal_add_chats();
  // @@protoc_insertion_point(field_add:chat.Chats.chats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ChatInfo >&
Chats::chats() const {
  // @@protoc_insertion_point(field_list:chat.Chats.chats)
  return _impl_.chats_;
}

// -------------------------------------------------------------------

// MessageChan

// string message_id = 1;
inline void MessageChan::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& MessageChan::message_id() const {
  // @@protoc_insertion_point(field_get:chat.MessageChan.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageChan::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.MessageChan.message_id)
}
inline std::string* MessageChan::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:chat.MessageChan.message_id)
  return _s;
}
inline const std::string& MessageChan::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void MessageChan::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageChan::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageChan::release_message_id() {
  // @@protoc_insertion_point(field_release:chat.MessageChan.message_id)
  return _impl_.message_id_.Release();
}
inline void MessageChan::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.MessageChan.message_id)
}

// .chat.Direction direction = 2;
inline void MessageChan::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::chat::Direction MessageChan::_internal_direction() const {
  return static_cast< ::chat::Direction >(_impl_.direction_);
}
inline ::chat::Direction MessageChan::direction() const {
  // @@protoc_insertion_point(field_get:chat.MessageChan.direction)
  return _internal_direction();
}
inline void MessageChan::_internal_set_direction(::chat::Direction value) {
  
  _impl_.direction_ = value;
}
inline void MessageChan::set_direction(::chat::Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:chat.MessageChan.direction)
}

// string chat_id = 3;
inline void MessageChan::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& MessageChan::chat_id() const {
  // @@protoc_insertion_point(field_get:chat.MessageChan.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageChan::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.MessageChan.chat_id)
}
inline std::string* MessageChan::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:chat.MessageChan.chat_id)
  return _s;
}
inline const std::string& MessageChan::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void MessageChan::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageChan::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageChan::release_chat_id() {
  // @@protoc_insertion_point(field_release:chat.MessageChan.chat_id)
  return _impl_.chat_id_.Release();
}
inline void MessageChan::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.MessageChan.chat_id)
}

// -------------------------------------------------------------------

// Message

// .chat.MessageType messageType = 1;
inline void Message::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::chat::MessageType Message::_internal_messagetype() const {
  return static_cast< ::chat::MessageType >(_impl_.messagetype_);
}
inline ::chat::MessageType Message::messagetype() const {
  // @@protoc_insertion_point(field_get:chat.Message.messageType)
  return _internal_messagetype();
}
inline void Message::_internal_set_messagetype(::chat::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void Message::set_messagetype(::chat::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:chat.Message.messageType)
}

// string message_json = 2;
inline void Message::clear_message_json() {
  _impl_.message_json_.ClearToEmpty();
}
inline const std::string& Message::message_json() const {
  // @@protoc_insertion_point(field_get:chat.Message.message_json)
  return _internal_message_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_message_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.Message.message_json)
}
inline std::string* Message::mutable_message_json() {
  std::string* _s = _internal_mutable_message_json();
  // @@protoc_insertion_point(field_mutable:chat.Message.message_json)
  return _s;
}
inline const std::string& Message::_internal_message_json() const {
  return _impl_.message_json_.Get();
}
inline void Message::_internal_set_message_json(const std::string& value) {
  
  _impl_.message_json_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message_json() {
  
  return _impl_.message_json_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_message_json() {
  // @@protoc_insertion_point(field_release:chat.Message.message_json)
  return _impl_.message_json_.Release();
}
inline void Message::set_allocated_message_json(std::string* message_json) {
  if (message_json != nullptr) {
    
  } else {
    
  }
  _impl_.message_json_.SetAllocated(message_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_json_.IsDefault()) {
    _impl_.message_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.Message.message_json)
}

// -------------------------------------------------------------------

// Messages

// repeated .chat.Message messages = 1;
inline int Messages::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int Messages::messages_size() const {
  return _internal_messages_size();
}
inline void Messages::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::chat::Message* Messages::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:chat.Messages.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::Message >*
Messages::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:chat.Messages.messages)
  return &_impl_.messages_;
}
inline const ::chat::Message& Messages::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::chat::Message& Messages::messages(int index) const {
  // @@protoc_insertion_point(field_get:chat.Messages.messages)
  return _internal_messages(index);
}
inline ::chat::Message* Messages::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::chat::Message* Messages::add_messages() {
  ::chat::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:chat.Messages.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::Message >&
Messages::messages() const {
  // @@protoc_insertion_point(field_list:chat.Messages.messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// UserID

// string user_id = 1;
inline void UserID::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& UserID::user_id() const {
  // @@protoc_insertion_point(field_get:chat.UserID.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserID::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.UserID.user_id)
}
inline std::string* UserID::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:chat.UserID.user_id)
  return _s;
}
inline const std::string& UserID::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void UserID::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserID::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserID::release_user_id() {
  // @@protoc_insertion_point(field_release:chat.UserID.user_id)
  return _impl_.user_id_.Release();
}
inline void UserID::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.UserID.user_id)
}

// -------------------------------------------------------------------

// MessageID

// string message_id = 1;
inline void MessageID::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& MessageID::message_id() const {
  // @@protoc_insertion_point(field_get:chat.MessageID.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageID::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.MessageID.message_id)
}
inline std::string* MessageID::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:chat.MessageID.message_id)
  return _s;
}
inline const std::string& MessageID::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void MessageID::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageID::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageID::release_message_id() {
  // @@protoc_insertion_point(field_release:chat.MessageID.message_id)
  return _impl_.message_id_.Release();
}
inline void MessageID::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.MessageID.message_id)
}

// -------------------------------------------------------------------

// ChatData

// string json = 1;
inline void ChatData::clear_json() {
  _impl_.json_.ClearToEmpty();
}
inline const std::string& ChatData::json() const {
  // @@protoc_insertion_point(field_get:chat.ChatData.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatData::set_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ChatData.json)
}
inline std::string* ChatData::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:chat.ChatData.json)
  return _s;
}
inline const std::string& ChatData::_internal_json() const {
  return _impl_.json_.Get();
}
inline void ChatData::_internal_set_json(const std::string& value) {
  
  _impl_.json_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatData::_internal_mutable_json() {
  
  return _impl_.json_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatData::release_json() {
  // @@protoc_insertion_point(field_release:chat.ChatData.json)
  return _impl_.json_.Release();
}
inline void ChatData::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  _impl_.json_.SetAllocated(json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.json_.IsDefault()) {
    _impl_.json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ChatData.json)
}

// -------------------------------------------------------------------

// ExchangedMessage

// string chat_id = 1;
inline void ExchangedMessage::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& ExchangedMessage::chat_id() const {
  // @@protoc_insertion_point(field_get:chat.ExchangedMessage.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangedMessage::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ExchangedMessage.chat_id)
}
inline std::string* ExchangedMessage::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:chat.ExchangedMessage.chat_id)
  return _s;
}
inline const std::string& ExchangedMessage::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void ExchangedMessage::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExchangedMessage::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExchangedMessage::release_chat_id() {
  // @@protoc_insertion_point(field_release:chat.ExchangedMessage.chat_id)
  return _impl_.chat_id_.Release();
}
inline void ExchangedMessage::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ExchangedMessage.chat_id)
}

// .chat.Message message = 2;
inline bool ExchangedMessage::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool ExchangedMessage::has_message() const {
  return _internal_has_message();
}
inline void ExchangedMessage::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::chat::Message& ExchangedMessage::_internal_message() const {
  const ::chat::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat::Message&>(
      ::chat::_Message_default_instance_);
}
inline const ::chat::Message& ExchangedMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.ExchangedMessage.message)
  return _internal_message();
}
inline void ExchangedMessage::unsafe_arena_set_allocated_message(
    ::chat::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ExchangedMessage.message)
}
inline ::chat::Message* ExchangedMessage::release_message() {
  
  ::chat::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat::Message* ExchangedMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:chat.ExchangedMessage.message)
  
  ::chat::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::chat::Message* ExchangedMessage::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::chat::Message* ExchangedMessage::mutable_message() {
  ::chat::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:chat.ExchangedMessage.message)
  return _msg;
}
inline void ExchangedMessage::set_allocated_message(::chat::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:chat.ExchangedMessage.message)
}

// -------------------------------------------------------------------

// ReadMessage

// string chat_id = 1;
inline void ReadMessage::clear_chat_id() {
  _impl_.chat_id_.ClearToEmpty();
}
inline const std::string& ReadMessage::chat_id() const {
  // @@protoc_insertion_point(field_get:chat.ReadMessage.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadMessage::set_chat_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ReadMessage.chat_id)
}
inline std::string* ReadMessage::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:chat.ReadMessage.chat_id)
  return _s;
}
inline const std::string& ReadMessage::_internal_chat_id() const {
  return _impl_.chat_id_.Get();
}
inline void ReadMessage::_internal_set_chat_id(const std::string& value) {
  
  _impl_.chat_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadMessage::_internal_mutable_chat_id() {
  
  return _impl_.chat_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadMessage::release_chat_id() {
  // @@protoc_insertion_point(field_release:chat.ReadMessage.chat_id)
  return _impl_.chat_id_.Release();
}
inline void ReadMessage::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    
  } else {
    
  }
  _impl_.chat_id_.SetAllocated(chat_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_id_.IsDefault()) {
    _impl_.chat_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ReadMessage.chat_id)
}

// string message_id = 2;
inline void ReadMessage::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& ReadMessage::message_id() const {
  // @@protoc_insertion_point(field_get:chat.ReadMessage.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadMessage::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat.ReadMessage.message_id)
}
inline std::string* ReadMessage::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:chat.ReadMessage.message_id)
  return _s;
}
inline const std::string& ReadMessage::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void ReadMessage::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadMessage::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadMessage::release_message_id() {
  // @@protoc_insertion_point(field_release:chat.ReadMessage.message_id)
  return _impl_.message_id_.Release();
}
inline void ReadMessage::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat.ReadMessage.message_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::chat::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::Direction>() {
  return ::chat::Direction_descriptor();
}
template <> struct is_proto_enum< ::chat::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::MessageType>() {
  return ::chat::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chat_5fservice_2eproto
